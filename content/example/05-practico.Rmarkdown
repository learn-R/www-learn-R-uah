---
title: "Limpieza de datos"
linktitle: "5: Limpieza de datos"
date: "2021-03-12"
menu:
  example:
    parent: Ejemplos
    weight: 5
type: docs
toc: true
editor_options: 
  chunk_output_type: console
---

```{r set up, echo = F}
knitr::opts_knit$set(sql.max.print = 10)
```

## 0. Objetivo del práctico

El objetivo de este práctico es introducir en la manipulacón de la estructura de los datos que posteriormente serán analizados. Ello incluye la selección de variables, el filtrado de filas, la eliminación de valores nulos, entre otros. 

Es así como esta práctica se enmarca en el proceso de **procesamiento de los datos**. Ello significa que **todos** los procedimientos que aprenderemos en esta sesión deben ser incorporados necesariamente en el código de procesamiento, a modo de elaborar un posterior código de análisis lo más limpio posible. 

## 1. Recursos de la práctica

En este práctico utilizaremos la base de datos de la [**Encuesta de Caracterización Socioeconómica (CASEN)**](http://observatorio.ministeriodesarrollosocial.gob.cl/encuesta-casen-en-pandemia-2020), la cual fue procesada en el [Práctico anterior]().Recuerden siempre consultar el [**manual/libro de códigos**](http://observatorio.ministeriodesarrollosocial.gob.cl/storage/docs/casen/2020/Libro_de_codigos_Base_de_Datos_Casen_en_Pandemia_2020.pdf) antes de trabajar una base de datos.

## 2. Librerías a utilizar

En este práctico utilizaremos las siguientes librerías

1. `pacman`: este facilita y agiliza la lectura de los paquetes a utilizar en R

2. `tidyverse`: colección de librerías, de la cual utilizaremos `dplyr`

3. `dplyr`: para manipular datos

4. `sjmisc`: para explorar datos

5. `magrittr`: nos permitirá ocupar dos operadores que en R son **muy** utilizados

# Procesamiento de datos

## 1. Cargar librerías

Lo primero es _cargar las librerías_ a utilizar. Para ello, acudimos a la función `p_load` del paquete `pacman`. Asumimos que ya está instalado, así que sólo lo cargaremos con la función `library()`

```{r cargar-paquetes, echo=TRUE}
pacman::p_load(tidyverse, #Universo de librerías para manipular datos
               haven, #Para cargar datos
               dplyr,#Para manipular datos 
               sjmisc,#Para explorar datos
               magrittr) #Para el operador pipeline (%>%)
```

## 2. Importar bases de datos

Cargaremos los datos 

```{r include=FALSE, warning= FALSE , message = F}
temp <- tempfile()
download.file("http://observatorio.ministeriodesarrollosocial.gob.cl/storage/docs/casen/2020/Casen_en_Pandemia_2020_STATA.dta.zip",temp)
datos <- haven::read_dta(unz(temp, "Casen en Pandemia 2020 STATA.dta"))
unlink(temp); remove(temp)
```

```{r eval=FALSE, include=TRUE}
datos <- read_dta("input/Casen en Pandemia 2020 STATA.dta") 
```

En el panel **Environment**, visualizamos los nuevos objetos, que poseen `r format( nrow(datos), decimal.mark="," , big.mark = ".")` observaciones (o filas) y `r format(ncol(datos), decimal.mark="," , big.mark = ".")` variables (columnas).

## 3. Explorar datos

A continuación, utilizaremos la función `head()` del paquete `base`, para revisar las primeras cinco filas del set de datos.  

```{r explorar-datos, echo=FALSE}
head(datos, 5)
```

Podemos ver diversas variables, tanto numéricas como con números etiquetados (¡esto último es un *clásico* cuando trabajamos con datos en .dta y .sav!)

## 4. Un aspecto clave antes de comenzar: los operadoresAspectos claves antes de comenzar 

Previo a trabajar con la base de datos, debemos repasar el concepto de **operadores**. Estos símbolos no son de uso exclusivo en R ¡probablemente los conoces desde tus cursos de matemática! Ahora bien, no todos tienen el mismo significado que en otros softwares.

Los **operadores** serán símbolos que permitirán, en los distintos procedimientos de procesamiento, simplificar procesos. Por ejemplo, serán útilizados cuando filtremos nuestros datos para personas de ciertas categorías, cuando calculemos variables nuevas (de manera aritmética o condicional) o, simplemente, cuando queramos hacer procesos "concatenados".

#### Operadores relacionales 

Se usan para hacer comparaciones. Cuando en la *Tabla 1* nos referimos a `un valor`, esto refiere tambien a `variables`

| Símbolo  | Función |
|---------:|:--------|
| `<`      |  Un valor es menor que otro |
| `>`      |  Un valor es mayor que otro |
| `==`     |  Un valor es igual que otro [^1] |
| `<=`     |  Un valor es menor o igual que otro |
| `>=`     |  Un valor es mayor o igual que otro |
| `!=`     |  Un valor es distinto o diferente que otro|
| `%in%`   |  Un valor pertenece al conjunto designado [^2] |
| `is.na()`|  El valor es perdido o `NA` |
| `!is.na()`| El valor es distinto de  `NA` |

[^1]: ¡Atención! Fíjate bien que `==` y `=` son distintos. En R `==` es indicar *"igual a"*, mientras que  `=` es *asignar* (sinónimo de `<-`)

[^2]: Este operador es **muy utilizado**, sirve para indicar que algo está dentro de una cadena de valores. 

#### Operadores aritméticos

Realizan operaciones, como la suma, resta, división, entre otros.

| Símbolo  | Función |
|---------:|:--------|
| `+`      |  Suma |
| `-`      |  Resta|
| `*`     |  Multiplicación |
| `/`     |  División |
| `^`     |  Elevado |

#### Operadores de asignación

Hay dos formas de asignar `objetoA <- objetoB` o `objetoA = objetoB`. Ambas implican que lo que se este realizando en el *objetoB* implica que eso va a producir o generar al *objetoA*

#### Operadores booleanos

Describen relaciones **lógicas** o **condicionales**

| Símbolo  | Función |
|---------:|:--------|
| `&`      |  Indica un *y* lógico |
| `|`      |  Indica un *o* lógico |
| `xor()`  |  Excluye la condición  |
| `!`      |  Distinto de ... |
| `any`    |  Ninguna de las condiciones serán utilizadas |
| `all`    |  Todas las condiciones serán ocupadas |


```{r, echo=FALSE, out.width="60%"}
knitr::include_graphics("/img/example/operad.png", error = FALSE)
```
Figura 1: Resumen de operadores

### Operador pipeline %>% 

¡Aquí mucha atención! Este operador `%>%` (llamado `pipe`) no es un operador que esté contenido en las funciones base del lenguaje R. Más bien proviene del paquete `magrittr` de `tidyverse`, y es de los operadores más útiles y utilizados en R.

¿Para qué sirve? pues nos permite concatenar múltiples funciones y procesos. *Imagina que quieres filtrar una base de datos a partir de tramos etarios. Pero no tienes esa variable creada. ¿Que hacer? La respuesta: concatenar el proceso de creación de variables y luego filtrar.* Eso se puede hacer gracias a ` %>% ` (ya mostraremos como utilizar esta herramienta), que por lo demás es muy fácil de ejecutar.

- `Ctrl + shift + M` Para Windows
- `⌘ + shift + M` Para Mac

## 5. Seleccionar variables

Lo primero que tenemos que considerar cuando trabajaremos con datos cuantitativos es tener claro qué análisis deseamos hacer. ¿Qué queremos investigar? ¿qué fenómeno de la realidad social me resulta interesante o relevante de conocer en profundidad? ¿**qué variables me permiten encontrar las respuestas que estoy buscando**? 

Ello permite destacar la estrecha relación existente entre el problema de investigación y el trabajo en R. En específico, **seleccionar sólo las variables que nos interesan** para trabajar facilitará la posterior manipulación de los datos, hará menos confuso el proceso e, incluso ¡hará que nuestros procedimientos sean menos exigentes en términos de memoria!

Aprenderemos dos maneras de seleccionar las variables que necesitamos

### a) Con R `base`

Si bien puede resultar menos cómodo que trabajar con paquetes como `dplyr`, aprender a trabajar con las librerías de R `base` puede ser sumamente útil en ciertas situaciones particulares. 

En este caso, estaremos interactuando con corchetes ("[ ]"). Para especificar a R que trabajaremos con columnas, debemos incorporar una coma luego del primer corchete ("[, ]"). Seleccionemos la primera variable de nuestros datos

```{r select_base_1, eval=F}
datos[, 1]
```

```{r select_base_1_t, include=FALSE}
head(datos[, 1], 5)
```
¡Podemos seleccionar más de una variable! Probemos con las variables número uno, dos y tres

```{r select_base_2, eval = F}
datos[, c(1,2,3)]
```

```{r select_base_2_t, include = F}
head(datos[, c(1,2,3)], 5)
```
También podemos seleccionar desde la variable X hasta la Y. En este caso, seleccionemos desde la primera a la quinta:

```{r select_base_3, eval = F}
datos[, 1:5]
```

```{r select_base_3_t, include = F}
head(datos[, 1:5], 5)
```

Y, obviamente, podemos utilizar el **nombre** de las variables

```{r select_base_4, eval = F}
datos[, c('sexo', 'metodologia_entrev')]
```

```{r select_base_4, include = F}
head(datos[, c('sexo', 'metodologia_entrev')], 5)
```

En este último caso, no olvidemos que el nombre de las variables debe ir entre comillas (""), pues R entiende que las palabras son `character`.

### b) Con `select()` de `dplyr`

De manera similar, la función `select()` de `dplyr` facilita el trabajo a la hora de seleccionar variables. Podemos utilizar tanto los nombres de las variables (¡esta vez no son necesarias las comillas!), como su número. Conozcamos la estructura de la función 

Si queremos incluir las variables `variable1`, `variable2` y `variable3`
{{< div "note" >}}
select(datos, variable1, variable2, variable3)
{{< /div >}}

Si queremos excluir anteponemos un menos `-variable1`
{{< div "note" >}}
select(datos, -variable1)
{{< /div >}}

Hay un montón de maneras de usar `select()` ¡vamos a conocerlas!

#### `select()` por indexación

La indexación refiere al orden que tiene la columna o variable dentro de los datos. Imaginemos que queremos seleccionar:

```{r, eval = F}
select(datos, 1, 2) # la primera y la segunda columna

select(datos, 1:4) # la primera hasta la cuarta columna

select(datos, c(1, 4, 5)) # la primera, la cuarta y la quinta columna columna
```

```{r, include = F}
head(select(datos, 1, 2), 5) # la primera y la segunda columna

head(select(datos, 1:4), 5) # la primera hasta la cuarta columna

head(select(datos, c(1, 4, 5), 5)) # la primera, la cuarta y la quinta columna columna
```

#### `select()` por nombre de columna

Si conocemos el nombre de la variable simplemente lo podemos poner y se seleccionará.

```{r, eval = F}
select(datos, edad, sexo, o1)
```

```{r, include = F}
head(select(datos, edad, sexo, o1), 5)
```

También puedo renombrar en el mismo proceso de selección indicando `nuevo_nombre = nombre_original` en el proceso de selección

```{r, eval = F}
select(datos, edad, sexo, ocupacion = o1)
```

```{r, include = F}
head(select(datos, edad, sexo, ocupacion = o1), 5)
```

#### `select()` para reordenar variables

Podemos seleccionar variables y luego indicar que queremos todo el resto de las variables (`everything()`). Solo por una cosa de orden. Esto será útil sobre todo cuando tengamos identificadores

```{r, eval = F}
select(datos, id_persona, sexo, edad, everything())
```

```{r, include = F}
head(select(datos, id_persona, sexo, edad, everything()), 5)
```

#### `select()` con patrones de texto

Podemos seleccionar variables considerando los prefijos, sufijos o partes de *cómo están nombradas las variables*. Independiente de qué tipo de patrón estes buscando, como todo texto y expresión regular en R (y gran parte de los carácteres) este texto debe venir entre **comillas**. Algunas de las funciones que posibilitan este proceso son:

- `starts_with()`: prefijo 
- `ends_with() `:  sufijo
- `contains()` : contiene una cadena de texto literal
- `matches()` : coincide con una expresión regular

```{r, eval = F}
select(datos, starts_with("a"), ends_with("preg"))

# También se pueden combinar con operadores logicos

select(datos, starts_with("y1")&ends_with("preg")) 
select(datos, contains("pobre")|contains("vivienda"))
select(datos, matches("pobreza_|vivienda"))
```

```{r, include = F}
head(select(datos, starts_with("a"), ends_with("preg")), 5)

# También se pueden combinar con operadores logicos

head(select(datos, starts_with("y1")&ends_with("preg")) , 5)
head(select(datos, contains("pobre")|contains("vivienda")), 5)
head(select(datos, matches("pobreza_|vivienda")), 5)
```

#### `select()` y condiciones lógicas

Si combinamos `select()` con `where()` obtendremos algo así como una frase *"seleciona donde"*, ese *donde* responde a una condición que cumple cierta variable. Por ejemplo, queremos seleccionar todas las variables que son carácteres (`is.character`):

```{r, eval = F}
select(datos, where(is.character))
```

```{r, include = F}
head(select(datos, where(is.character)), 5)
```

Luego de la revisión del libro de códigos y la exploración de datos mediante a funciones como `find_var()` de `sjmisc` decidimos trabajar con las siguientes variables.

- `edad`
- `sexo`
- `s13`: previsión de salud
- `tot_per`: número de personas en el hogar
- `ytoth`: ingresos totales del hogar
- `o1`: ocupación
- `y26d_total`: Monto del IFE
- `y26d_hog`: ¿Alguien recibió el IFE?

¡Apliquémos conocimientos!

```{r, eval = F}
select(datos, edad, sexo, prev =592, ocupacion = o1, tot_per, ytoth, starts_with("y26d_")&matches("total|hog"))
```

```{r, include = F}
head(select(datos, edad, sexo, prev =592, ocupacion = o1, tot_per, ytoth, starts_with("y26d_")&matches("total|hog")), 5)
```

Es una buena práctica trabajar solo con las columnas que utilizaremos para el análisis, principalmente pues disminuye el *uso de memoria*

```{r}
datos_proc <- select(datos, edad, sexo, prev = 592, ocupacion = o1, tot_per, ytoth, starts_with("y26d_")&matches("total|hog"))
```

El nuevo objeto posee`r format(ncol(datos), decimal.mark="," , big.mark = ".")` variables (columnas), pero conserva las filas `r format( nrow(datos), decimal.mark="," , big.mark = ".")` (u observaciones) ¿Qué pasa si quiero trabajar con un *subset* de casos? La respuesta es `filter()`

## 6. Filtrar valores

Asimismo, así como no siempre vamos a trabajar con todas las variables que contiene un conjunto de datos en su versión original (¡imaginen trabajar con las más de 500 variables de CASEN al mismo tiempo!), no siempre desearemos trabajar con todas las observaciones que tenemos en los datos. Tal como en el caso de la selección de variables, podemos recurrir tanto a R `base` como a `dplyr` para filtrar nuestros datos.

### a) Con R `base`

En este caso, en lugar de poner la coma junto al primer corchete ("[, ]"), lo haremos antes del segundo ("[ ,]") ¡veamos cómo hacerlo!

Filtramos para sólo presentar a los hombres

```{r filter_base_1, eval = F}
datos_proc[datos_proc$sexo == 2,]
```

```{r filter_base_1_t, include = F}
head(datos_proc[datos_proc$sexo == 2,], 5)
```

Incluso es posible incorporar más de un filtro a la vez ¡simplemente ocuparemos los operadores que revisamos al inicio!

```{r filter_base_2, eval = F}
datos_proc[datos_proc$sexo == 2 & datos_proc$edad >= 33,]
```

```{r filter_base_2_t, include = F}
head(datos_proc[datos_proc$sexo == 2 & datos_proc$edad >= 33,], 5)
```

También podemos ocupar el operador `%in%`

```{r filter_base_3, eval = F}
datos_proc[datos$sexo == 2 & datos$edad >= 33,]
```

```{r filter_base_3_t, include = F}
head(datos_proc[datos_proc$prev %in% c(1,3,4),], 5)
```

### b) Con `filter` de `dplyr`

La función `filter()` de `dplyr` escoge o extrae filas basados en sus valores, subdivide un data frame (*subset*), reteniendo todas las filas que satisfacen sus condiciones.

Con `filter()` será esencial el uso de los **operadores** que ya vimos, dado que las observaciones que preservarán en nuestros datos (y aquellas que no), están definidas por condiciones lógicas (relacionales o booleanas)

{{< div "note" >}}
filter(datos, condicion_para filtrar)
Esta condición para filtrar podría ser, por ejemplo
variable1 >= 3
{{< /div >}}

#### `filter` con números

Imaginémos que queremos una base con las personas mayores de 15 años. Pero también que pertenezcan a hogares con menos de 7 personas. 

```{r, eval = F}
filter(datos_proc, edad >= 15)
filter(datos_proc, edad >= 15 & tot_per <7)
```

```{r, include = F}
head(filter(datos_proc, edad >= 15), 5)
head(filter(datos_proc, edad >= 15 & tot_per <7), 5)
```

¿Y si quiero filtrar para saber el valor máximo de ingresos (`ytoth`)?

```{r}
filter(datos_proc, ytoth == max(ytoth))
```

¡Gana \$225.200.000, es Hombre y tiene 41 años! (y vive solo...)


#### `filter()` con caracteres

Si queremos filtrar por la variable `sexo` solo a las mujeres, tengo dos opciones: o solo selecciono a las mujeres (`==`) o excluyo a los hombres (`!=`).

Ahora bien, antes hay que hacer una precisión importante: en los datos `sexo` es una variable que está como `dbl` y `lbl` (número etiquetado), por lo que no es que en la base aparezcan "Mujeres" y "Hombres", sino que 2 y 1.

Por ello, con el siguiente código aparecerá un error.

```{r, error = T}
filter(datos_proc, sexo == "Mujer")
```

Una función **muy muy útil** (sobre todo cuando trabajemos con regresiones) es `as_factor()` que permite conservar los niveles pero definiendo sus categorías de respuesta en base a la etiqueta que traen (el `lbl`) 

```{r}
datos_proc$sexo <- as_factor(datos_proc$sexo)
```

¡Ahora si funcionará!

```{r, eval = F}
filter(datos_proc, sexo == "Mujer")
filter(datos_proc, sexo != "Hombre")
```

```{r, include = F}
head(filter(datos_proc, sexo == "Mujer"), 5)
head(filter(datos_proc, sexo != "Hombre"), 5)
```

{{< div "note" >}}
**Ojo**. R es *sensible* a cómo está escrito el texto. Si pones el mismo código pero sin respetar mayúsuculas y minúsculas el código no funcionará
{{< /div >}}

¡Por último! ¿Cómo se seleccionan dos condiciones en carácter? Con el operador `%in%`

```{r, eval = F}
datos_proc$prev <- as_factor(datos_proc$prev)

filter(datos_proc, prev %in% c("Sistema Público FONASA", "ISAPRE") & edad >= 65)
```

```{r, include = F}
datos_proc$prev <- as_factor(datos_proc$prev)

head(filter(datos_proc, prev %in% c("Sistema Público FONASA", "ISAPRE") & edad >= 65), 5)
```

## 7. Tratamiento de casos perdidos (`NA`)

Los datos con los que trabajamos suelen incorporar valores nulos (`NA`), casos perdidos ingresados como valores de clase `Logic`. Estos valores no nos entregan información útil para nuestros análisis, y pueden generar problemas al momento de, por ejemplo, calcular _medidas de tendencia central_, u otros procedimientos estadísticos.

Hay diversas maneras de trabajar los valores nulos, tales como realizar procesos de imputación, entre otros. Sin embargo, la más sencilla consiste en **eliminar los valores nulos** que se encuentran presentes en nuestros datos (aunque no recomendable)

Para ello, lo primero es _identificar valores nulos_ en el set de datos en general, o en alguna variable en específico. Para ello, empleamos la función `is.na()`.

```{r, eval=FALSE}

is.na(datos_proc) #Revisamos si hay casos perdidos en el total del set de datos 
is.na(datos_proc$ytoth) #Revisamos si hay casos perdidos en Ingresos per cápita

```

```{r, include=FALSE}

head(is.na(datos_proc), 10) #Revisamos si hay casos perdidos en el total del set de datos 
head(is.na(datos_proc$ytoth), 10) #Revisamos si hay casos perdidos en Ingresos per cápita

```

Sin embargo, esto no resulta muy práctico para el análisis. Es por ello que emplearemos la función `sum()` para _contar cuántos valores nulos_ hay en el set de datos en general, o en alguna variable en particular. 

```{r}

sum(is.na(datos_proc)) #Contamos los valores nulos del set de datos en general, que suman un total de 180.148
sum(is.na(datos_proc$ytoth)) #Contaremos los valores nulos de la variable Ingresos per cápita, que alcanzan un total de 98

```

Una vez identificamos los _valores nulos_, podemos proceder a **eliminarlos** del set de datos. El comando `na.omit()` eliminará _todas las filas_ que presenten casos perdidos. 

```{r}
nrow(datos_proc)
datos_proc <- na.omit(datos_proc) #Eliminamos las filas con casos perdidos
nrow(datos_proc) #La nueva base de datos tiene 5.387 filas y 4 columnas
```

¡La próxima sesión aprenderemos a recodificarlas!

## 8. Resumen con procesamiento de las variables

Hasta ahora, solo hemos creado una base de datos que selecciona variables. Ahora nos resta incorporar en un nuevo objeto los cambios que nos parezcan relevantes para la base de datos procesada que utilizaremos en nuestros análisis. 

Como ya conocemos operadores que permiten concatenar procesos ( `%>%`  y `%$%`) este procedimiento será mucho más fácil. 

```{r, eval = F}
datos_proc %>% 
 filter(edad >= 15 & tot_per <7) %>%
 select(sexo, edad, ocupacion, ytoth, tot_per, ife = y26d_hog) %>% 
 na.omit()
```

```{r, include = F}
head(datos_proc %>% 
 filter(edad >= 15 & tot_per <7) %>%
 select(sexo, edad, ocupacion, ytoth, tot_per, ife = y26d_hog) %>% 
 na.omit(), 5)
```

¡Ahora que estamos seguras/os sobre-escribimos la base!
```{r}
datos_proc <- datos_proc %>% 
               filter(edad >= 15 & tot_per <7) %>%
               select(sexo, edad, ocupacion, ytoth, tot_per, ife = y26d_hog) %>% 
               na.omit()
```

Podemos visualizar la base resultante a partir de `view_df()` de `sjPlot`
```{r}
sjPlot::view_df(datos_proc)
```

## 9. Guardar base procesada

Para guardar la base de datos procesada, debes dirigir la ruta hacia tu Rproject

```{r eval=FALSE, include=TRUE}
saveRDS(datos_proc, file = "output/datos_proc.rds")
```

# Resumen

En ete práctico 

1. Conocimos los **operadores booleanos, de asignación y condicionales**
1. Aprendimos a seleccionar variables con R `base` y `dplyr`
1. Aprendimos a filtrar valores con R `base` y `dplyr`
1. Aprendimos a concatenar procesos con el operador `pipe (%>%)` 


## 4. Agrupar por filas con `rowwise()`

Como sabemos, la librería `dplyr` de `tidyverse` provee diversas herramientas que nos permiten manipular los datos con los cuales nos encontramos trabajando. Una de ellas es su función `rowwise()`, que posibilita **agrupar los datos en razón de las filas**. Esto es particularmente útil cuando, por ejemplo, queremos construir algún índice. En este caso, utilizaremos las diversas variables de ingresos para construir la variable `ing_tot`, que incluirá los ingresos totales percibidos por las y los trabajadores, en razón de sus sueldos y salarios netos; sus sueldos y salarios variables; y por las regalías entregadas por parte de las y los empleadores. 

```{r rowwise, echo=TRUE}
datos <- datos %>% #Especificamos que trabajaremos con el dataframe datos
  rowwise() %>% #Especificamos que agruparemos por filas
  mutate(ing_tot = sum(ss_t, svar_t, reg_t)) #Creamos una nueva variable llamada ing_tot, sumando los valores de ss_t, svar_t y reg_t para cada fila 
head(datos)
```

Como vemos, ahora el set de datos pasó de tener 8 a `r format(ncol(datos), decimal.mark="," , big.mark = ".")` variables (columnas). Sin embargo, la cantidad de filas se mantiene constante, con un total de `r format( nrow(datos), decimal.mark="," , big.mark = ".")`.

Sin embargo, como ya no utilizaremos `ss_t`, `svar_t` ni `reg_t` por separado, las des-seleccionaremos con `select()` de `dplyr`

```{r deselect, echo=TRUE}
datos <- datos %>% 
  select(-c(ss_t, svar_t, reg_t))
head(datos)
```


## 5. Agrupar por columnas con `group_by()`

Otra de las funciones de `dplyr` que nos permiten manipular los datos es `group_by`. En este caso, en lugar de agrupar los valores por filas, podremos hacerlo en razón de las **columnas**. Calculemos ahora la media de `ing_tot` con la función `mean()`, agrupando por `sexo`:

```{r group_by, echo = T}
datos %>% 
  group_by(sexo) %>% #Espeficicamos que agruparemos por sexo
  summarise(media = mean(ing_tot)) #Creamos una columna llamada media, calculando la media ingresos con la función `mean`
```

Es importante destacar que la función `summarise()` (o `summarize()`) de `dplyr` nos permite crear un nuevo data frame con una o más filas para cada combinación y agrupación de variables. En este caso, tenemos dos filas: una para Hombre, y otra para Mujer. En caso de no agrupar variables, sólo tendremos una columna que **resuma** las observaciones especificadas. 

Algo interesante es que podemos combinar `group_by()` con algunas funciones de `sjmisc`. Probemos calculando la frecuencia de hombres y mujeres agrupando por cada sector:

```{r group_by_frq1, echo = TRUE}
datos %>% 
  group_by(sector) %>% 
  frq(sexo)
```

Obtendremos una tabla por cada una de las categorías de la variable por la cual agrupamos (en este caso, una por cada sector), que señala las frecuencias absolutas y relativas de cada sexo para cada sector. Por supuesto, también podemos hacer el mismo ejercicio con `descr()`. Probemos haciendo un análisis descriptivos de ingresos para cada sexo:

```{r group_by_frq, echo = TRUE}
datos %>% 
  group_by(sexo) %>% 
  descr(ing_tot)
```

En este caso, obtenemos dos tablas: una por cada `sexo`, cada una indicando las estadísticas de resumen para la variable `ing_tot`

## 6. Manipulación de datos (tidydata)

Otra de las librerías de `tidyverse` que resulta de gran utilidad es `tidyr`. En este caso, cada una de las filas de nuestros datos indican a un sujeto (el cual constituye la unidad de análisis). Las funciones `pivot_longer()` y `pivot_wider()` de la librería anteriormente señalada nos permitirán pivotear los datos, para transformarlos a un dataframe de formato **long** (largo) o **wide** (ancho), respectivamente. 

### a) `pivot_longer()`

Como ya se señaló, `pivot_longer()`nos permitirá pivotear los datos de manera tal que estos se transformen a un tabulado en formato **long**. Ello implica que el tabulado tendrá un mayor número de observaciones, reduciendo su cantidad de columnas. En este caso, pivotearemos todas las columnas salvo `sector`, lo cual significa que tales columnas se subsumirán en una sola (en este caso, llamada "variable"), y sus respectivos valores en otra (en este caso, llamada "value"). Luego, la unidad de análisis pasará, de ser sujetos, a ser las variables. Para ello usamos el siguiente código:

```{r pivot-longer, echo=TRUE}
long <- datos %>% #Creamos un nuevo objeto a partir de datos
  select(-ing_tot) %>%  #Des-seleccionamos la variable ing_tot, pues es de class numeric
  pivot_longer(cols=-c(1, id), #Pivoteamos a lo largo todas las columnas salvo la primera (sector) 
               names_to = "variable", #Especificamos que la columna "variable" incluirá los nombres de cada una de las columnas pivoteadas
               values_to = "value") #Especificamos que la columna "value" incluirá los valores de cada una de las columnas pivoteadas
head(long)
```

Podemos darnos cuenta de que ahora nuestro set de datos sólo contiene 4 columnas, pero `r format( nrow(long), decimal.mark="," , big.mark = ".")` filas. Podemos darnos cuenta que ahora, cada cuatro columnas, tenemos a un sujeto de la muestra. 

### b) `pivot_wider`

Asimismo, las tablas largas (long) pueden ser transformadas a tablas anchas (wide) con la función `pivot_wider()`, lo cual implica que nuestra tabla reducirá su cantidad de filas y aumentará su número de columnas. Para ello, sólo debemos especificar desde dónde extraeremos los nombres y los valores asociados a las nuevas columnas: 

```{r pivot_wider, echo=TRUE}
wide <- long %>% #Creamos un nuevo objeto a partir de los datos de long 
  pivot_wider(names_from = "variable", #Pivoteamos, tomando el nombre de las columnas desde la columna "variable"
              values_from = "value") 
head(wide)
```

Los datos se "ensancharon", pasando a tener `r format( nrow(wide), decimal.mark="," , big.mark = ".")` filas y `r format( ncol(wide), decimal.mark="," , big.mark = ".")` columnas. 

## 7. `separate()`

La función `separate()` de `tidyr` nos permite convertir un character individual de una columna en múltiples columnas. En este caso, crearemos una nueva variable `sobre_prom`, que nos indicará si los ingresos de los sujetos están por sobre o por debajo de la media de ingresos. Luego, separaremos la primera y la segunda palabra (caracteres) de cada unos de los valores en dos columnas distintas.

```{r separate, echo = T}
separate <- datos %>% #Creamos un nuevo objeto desde datos
  mutate(sobre_prom = case_when(ing_tot <= mean(ing_tot) ~ "Bajo media", 
                                ing_tot > mean(ing_tot) ~ "Sobre media")) %>% #Creamos una variable condicional con case_when(), para identificar quienes estan bajo y sobre la media de ingreso
  separate(sobre_prom, #Especificamos la columna que queremos separar
           into = c("sobre_o_bajo", "media")) #Especificamos en cuántas columnas queremos separar los characteres, y cómo se llamarán tales columnas
head(separate)
```

## 8. `unite()`

También podemos unir caracteres de columnas distintas, con la función `unite()` de `tidyr`. En este caso, volveremos a unir las columnas ¿Sobre o bajo? y Media en una sola, llamada sobre_prom. Por defecto, `unite()` une los caracteres con guiones bajos (_). Podemos especificar un nuevo separador con el argumento `sep`. En este caso, el separador será un espacio (" ")

```{r unite, echo = T}
separate <- separate %>% #Modificamos el objeto separate
  unite(col = sobre_media, #Unimos en una nueva columna llamada sobre_media
        sobre_o_bajo:media, #Especificamos las columnas que deseamos unir
        sep = " ") #Especificamos el separador
head(separate)
```

## 9. Unir datos 

Otra de las herramientas fundamentales a la hora de trabajar con la estructura de los datos es unir dos tabulados distintos con los cuales estemos trabajando. 

### a) `merge`

Una de las funciones más utilizadas para ello es `merge` del paquete `base` de R. Esta nos permite unir dos tabulados (data frames) que compartan una columna, y que tengan la misma cantidad de filas. 

```{r merge, echo = T}
esi2020_m <- readRDS(gzcon(url("https://github.com/learn-R/05-class/blob/main/input/data/ESI2020m.rds?raw=true"))) #Cargamos los datos que deseamos unir
datos_unidos <- merge(x = datos, #Unimos el dataframe datos
      y = esi2020_m, #con el dataframe esi2020_m
      by = c("sexo", "ing_tot")) #a partir de las columnas "sexo" e "ing_tot"
head(datos_unidos)
```

Podemos ver que ahora el tabulado `datos` tiene 7 columnas el lugar de 6, pues se incorporó la columna `efectivas`, que estaba presente en `esi2020_m`, pero no en `datos`.

### b) `bind_cols()`

Otra cosa que podemos hacer es, simplemente, pegar una columna de un dataframe a otro. Para ello recurrimos a la función `bind_cols()` de `dplyr`:

```{r bind_cols, echo = T}
a <- select(datos, 1:5) # Seleccionamos las primeras cinco columnas de datos
b <- select(datos, 3:7) # Seleccionamos las últimas cinco columnas de datos
col_un <- bind_cols(a, b) #Unimos ambos dataframes a partir de sus columnas
head(col_un)
```

Vemos que simplemente pegó  `a` y `b`. Eso implica que tenemos columnas repetidas. Cuando estemos seguras/os de que hay columnas repetidas entre dos dataframes que queramos unir, emplearemos `merge()` mientras que, si estos no comparten ninguna columna, recurrimos a `bing_cols()`

### c) `bind_rows()`

También podemos unir dos dataframes a partir de sus filas, con la función `bind_rows()` de `dplyr`

```{r bind_rows, echo = T}
a <- a[1:10000,] # Seleccionamos las primeras 10.000 filas de a
b <- b[10001:18985,] # Seleccionamos las últimas 8.985 filas de b
row_un <- bind_rows(a, b)
head(row_un)
```

`bind_rows()` nos permite pegar filas, independientemente si ambos dataframes comparten las mismas columnas. En caso de que ambos dataframes no compartan alguna columna, esta función rellenará con valores nulos (`NA`)

# Resumen

En este práctico aprendimos a

1. Agrupar datos por filas y columnas.
2. Manipular datos (tidydata), transformando la estructura de estos a una ancha o larga. 
3. Separar y unir caracteres de una columna.
4. Unir datos, a partir de filas y columnas. 

# Reporte de progreso

¡No olviden llenar el [reporte de progreso](https://learn-r.formr.org)! En tu correo electrónico está disponible el código mediante al cuál debes acceder para actualizar tu estado de avance del curso.



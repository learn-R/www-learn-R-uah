---
title: "Tidydata y manipulación de datos"
linktitle: "5: Tidydata y manipulación de datos"
date: "2021-08-13"
menu:
  example:
    parent: Ejemplos
    weight: 5
type: docs
toc: true
editor_options: 
  chunk_output_type: console
---

```{r set up, echo = F}
knitr::opts_knit$set(sql.max.print = 10)
```

## 0. Objetivo del práctico

El objetivo del presente práctico es aprender a manipular datos, en particular, agrupar datos según alguna(s) columna(s) o filas en particular,  pivotando sets de datos, y uniendo y/o separando datos. 

## 1. Recursos de la práctica

Los datos a utilizar provienen de la [Encuesta Suplementaria de Ingresos (ESI) en su versión 2020](https://www.ine.cl/estadisticas/sociales/ingresos-y-gastos/encuesta-suplementaria-de-ingresos), módulo de la Encuesta Nacional de Empleo (ENE), levantada una vez al año para caracterizar los ingresos laborales de quienes son clasificadas/os como ocupadas/os en la ENE, y otras fuentes de ingresos de los hogares. No olvides que, cuando trabajes con datos, debes revisar la **documentación anexa**, como el [**libro de códigos**](https://www.ine.cl/docs/default-source/encuesta-suplementaria-de-ingresos/bbdd/manual-y-guía-de-variables/2020/personas-esi-2020.pdf?sfvrsn=f196cb4e_4).

## 2. Librerías a utilizar

En este práctico utilizaremos las siguientes librerías

1. `pacman`: este facilita y agiliza la lectura de los paquetes a utilizar en R

2. `tidyverse`: colección de librerías, de la cual utilizaremos `tidyr`, `haven` y `dplyr`

3. `tidyr`: permite pivotear los set de datos con los cuales estamos trabajando

4. `dplyr`: para manipular datos

5. `sjmisc`: para explorar datos


# Procesamiento de datos

## 1. Cargar librerías

Lo primero es _cargar las librerías_ a utilizar. Para ello, acudimos a la función `p_load` del paquete `pacman`. Asumimos que ya está instalado, así que sólo lo cargaremos con la función `library()`

```{r cargar-paquetes, echo=TRUE}
library(pacman)
pacman::p_load(tidyverse, #Universo de librerías para manipular datos
               tidyr, #Para pivotear la estructura de los datos
               dplyr,#Para manipular datos 
               sjmisc)#Para explorar datos
```

## 2. Importar bases de datos

Cargaremos los datos 

```{r importar-datos, echo=TRUE}
datos <- readRDS(gzcon(url("https://github.com/learn-R/05-class/blob/main/input/data/ESI2020.rds?raw=true")))
```

En el panel **Environment**, visualizamos los nuevos objetos, que poseen `r format( nrow(datos), decimal.mark="," , big.mark = ".")` observaciones (o filas) y `r format(ncol(datos), decimal.mark="," , big.mark = ".")` variables (columnas).

## 3. Explorar datos

A continuación, utilizaremos la función `View()` del paquete `base`, para revisar el set de datos.  

```{r explorar-datos, echo=FALSE}
View(datos)
```

Ocupamos, además, la función `frq()` de la librería `sjmisc`, para explorar las categorías de las variables de clase factor:

```{r frq-variables, echo=TRUE}
frq(datos$sector)
frq(datos$sexo)
frq(datos$prevision)
frq(datos$salud)
frq(datos$contrato_dur)
```

Podemos darnos cuenta de que la variable `sector` provee información sobre el _sector donde se encuentra ocupado/a el/la trabajador/a_; la variable `sexo` indica el _sexo de las y los trabajadores_; las columnas `prevision` y `salud` proveen información sobre _si el/la empleador/a paga cotizaciones relativas a los sistemas previsional y de salud_ a las y los trabajadores; y la variable `contrato_dur` provee información sobre la _duración del contrato_ de las y los trabajadores. 

Ahora exploremos las variables numéricas con `descr()` de `sjmisc`

```{r descr_variables, echo=T}
descr(datos$ss_t) #Ingresos por sueldo y salarios netos
descr(datos$svar_t) #Ingresos por sueldos y salarios variables
descr(datos$reg_t) #Total ingresos por regalías (beneficios entregados por el empleador)
```

Estas variables proveen información sobre _Ingresos por sueldo y salarios netos_ (`ss_t`); _Ingresos por sueldos y salarios variables_ (`svar_t`); y respecto a _Total ingresos por regalías (beneficios entregados por el empleador)_ (`reg_t`).

## 4. Agrupar por filas con `rowwise()`

Como sabemos, la librería `dplyr` de `tidyverse` provee diversas herramientas que nos permiten manipular los datos con los cuales nos encontramos trabajando. Una de ellas es su función `rowwise()`, que posibilita **agrupar los datos en razón de las filas**. Esto es particularmente útil cuando, por ejemplo, queremos construir algún índice. En este caso, utilizaremos las diversas variables de ingresos para construir la variable `ing_tot`, que incluirá los ingresos totales percibidos por las y los trabajadores, en razón de sus sueldos y salarios netos; sus sueldos y salarios variables; y por las regalías entregadas por parte de las y los empleadores. 

```{r rowwise, echo=TRUE}
datos <- datos %>% #Especificamos que trabajaremos con el dataframe datos
  rowwise() %>% #Especificamos que agruparemos por filas
  mutate(ing_tot = sum(ss_t, svar_t, reg_t)) #Creamos una nueva variable llamada ing_tot, sumando los valores de ss_t, svar_t y reg_t para cada fila 
head(datos)
```

Como vemos, ahora el set de datos pasó de tener 8 a `r format(ncol(datos), decimal.mark="," , big.mark = ".")` variables (columnas). Sin embargo, la cantidad de filas se mantiene constante, con un total de `r format( nrow(datos), decimal.mark="," , big.mark = ".")`.

Sin embargo, como ya no utilizaremos `ss_t`, `svar_t` ni `reg_t` por separado, las des-seleccionaremos con `select()` de `dplyr`

```{r deselect, echo=TRUE}
datos <- datos %>% 
  select(-c(ss_t, svar_t, reg_t))
head(datos)
```


## 5. Agrupar por columnas con `group_by()`

Otra de las funciones de `dplyr` que nos permiten manipular los datos es `group_by`. En este caso, en lugar de agrupar los valores por filas, podremos hacerlo en razón de las **columnas**. Calculemos ahora la media de `ing_tot` con la función `mean()`, agrupando por `sexo`:

```{r group_by, echo = T}
datos %>% 
  group_by(sexo) %>% #Espeficicamos que agruparemos por sexo
  summarise(media = mean(ing_tot)) #Creamos una columna llamada media, calculando la media ingresos con la función `mean`
```

Es importante destacar que la función `summarise()` (o `summarize()`) de `dplyr` nos permite crear un nuevo data frame con una o más filas para cada combinación y agrupación de variables. En este caso, tenemos dos filas: una para Hombre, y otra para Mujer. En caso de no agrupar variables, sólo tendremos una columna que **resuma** las observaciones especificadas. 

Algo interesante es que podemos combinar `group_by()` con algunas funciones de `sjmisc`. Probemos calculando la frecuencia de hombres y mujeres agrupando por cada sector:

```{r group_by_frq1, echo = TRUE}
datos %>% 
  group_by(sector) %>% 
  frq(sexo)
```

Obtendremos una tabla por cada una de las categorías de la variable por la cual agrupamos (en este caso, una por cada sector), que señala las frecuencias absolutas y relativas de cada sexo para cada sector. Por supuesto, también podemos hacer el mismo ejercicio con `descr()`. Probemos haciendo un análisis descriptivos de ingresos para cada sexo:

```{r group_by_frq, echo = TRUE}
datos %>% 
  group_by(sexo) %>% 
  descr(ing_tot)
```

En este caso, obtenemos dos tablas: una por cada `sexo`, cada una indicando las estadísticas de resumen para la variable `ing_tot`

## 6. Manipulación de datos (tidydata)

Otra de las librerías de `tidyverse` que resulta de gran utilidad es `tidyr`. En este caso, cada una de las filas de nuestros datos indican a un sujeto (el cual constituye la unidad de análisis). Las funciones `pivot_longer()` y `pivot_wider()` de la librería anteriormente señalada nos permitirán pivotear los datos, para transformarlos a un dataframe de formato **long** (largo) o **wide** (ancho), respectivamente. 

### a) `pivot_longer()`

Como ya se señaló, `pivot_longer()`nos permitirá pivotear los datos de manera tal que estos se transformen a un tabulado en formato **long**. Ello implica que el tabulado tendrá un mayor número de observaciones, reduciendo su cantidad de columnas. En este caso, pivotearemos todas las columnas salvo `sector`, lo cual significa que tales columnas se subsumirán en una sola (en este caso, llamada "variable"), y sus respectivos valores en otra (en este caso, llamada "value"). Luego, la unidad de análisis pasará, de ser sujetos, a ser las variables. Para ello usamos el siguiente código:

```{r pivot-longer, echo=TRUE}
long <- datos %>% #Creamos un nuevo objeto a partir de datos
  select(-ing_tot) %>%  #Des-seleccionamos la variable ing_tot, pues es de class numeric
  pivot_longer(cols=-c(1, id), #Pivoteamos a lo largo todas las columnas salvo la primera (sector) 
               names_to = "variable", #Especificamos que la columna "variable" incluirá los nombres de cada una de las columnas pivoteadas
               values_to = "value") #Especificamos que la columna "value" incluirá los valores de cada una de las columnas pivoteadas
head(long)
```

Podemos darnos cuenta de que ahora nuestro set de datos sólo contiene 4 columnas, pero `r format( nrow(long), decimal.mark="," , big.mark = ".")` filas. Podemos darnos cuenta que ahora, cada cuatro columnas, tenemos a un sujeto de la muestra. 

### b) `pivot_wider`

Asimismo, las tablas largas (long) pueden ser transformadas a tablas anchas (wide) con la función `pivot_wider()`, lo cual implica que nuestra tabla reducirá su cantidad de filas y aumentará su número de columnas. Para ello, sólo debemos especificar desde dónde extraeremos los nombres y los valores asociados a las nuevas columnas: 

```{r pivot_wider, echo=TRUE}
wide <- long %>% #Creamos un nuevo objeto a partir de los datos de long 
  pivot_wider(names_from = "variable", #Pivoteamos, tomando el nombre de las columnas desde la columna "variable"
              values_from = "value") 
head(wide)
```

Los datos se "ensancharon", pasando a tener `r format( nrow(wide), decimal.mark="," , big.mark = ".")` filas y `r format( ncol(wide), decimal.mark="," , big.mark = ".")` columnas. 

## 7. `separate()`

La función `separate()` de `tidyr` nos permite convertir un character individual de una columna en múltiples columnas. En este caso, crearemos una nueva variable `sobre_prom`, que nos indicará si los ingresos de los sujetos están por sobre o por debajo de la media de ingresos. Luego, separaremos la primera y la segunda palabra (caracteres) de cada unos de los valores en dos columnas distintas.

```{r separate, echo = T}
separate <- datos %>% #Creamos un nuevo objeto desde datos
  mutate(sobre_prom = case_when(ing_tot <= mean(ing_tot) ~ "Bajo media", 
                                ing_tot > mean(ing_tot) ~ "Sobre media")) %>% #Creamos una variable condicional con case_when(), para identificar quienes estan bajo y sobre la media de ingreso
  separate(sobre_prom, #Especificamos la columna que queremos separar
           into = c("sobre_o_bajo", "media")) #Especificamos en cuántas columnas queremos separar los characteres, y cómo se llamarán tales columnas
head(separate)
```

## 8. `unite()`

También podemos unir caracteres de columnas distintas, con la función `unite()` de `tidyr`. En este caso, volveremos a unir las columnas ¿Sobre o bajo? y Media en una sola, llamada sobre_prom. Por defecto, `unite()` une los caracteres con guiones bajos (_). Podemos especificar un nuevo separador con el argumento `sep`. En este caso, el separador será un espacio (" ")

```{r unite, echo = T}
separate <- separate %>% #Modificamos el objeto separate
  unite(col = sobre_media, #Unimos en una nueva columna llamada sobre_media
        sobre_o_bajo:media, #Especificamos las columnas que deseamos unir
        sep = " ") #Especificamos el separador
head(separate)
```

## 9. Unir datos 

Otra de las herramientas fundamentales a la hora de trabajar con la estructura de los datos es unir dos tabulados distintos con los cuales estemos trabajando. 

### a) `merge`

Una de las funciones más utilizadas para ello es `merge` del paquete `base` de R. Esta nos permite unir dos tabulados (data frames) que compartan una columna, y que tengan la misma cantidad de filas. 

```{r merge, echo = T}
esi2020_m <- readRDS(gzcon(url("https://github.com/learn-R/05-class/blob/main/input/data/ESI2020m.rds?raw=true"))) #Cargamos los datos que deseamos unir
datos_unidos <- merge(x = datos, #Unimos el dataframe datos
      y = esi2020_m, #con el dataframe esi2020_m
      by = c("sexo", "ing_tot")) #a partir de las columnas "sexo" e "ing_tot"
head(datos_unidos)
```

Podemos ver que ahora el tabulado `datos` tiene 7 columnas el lugar de 6, pues se incorporó la columna `efectivas`, que estaba presente en `esi2020_m`, pero no en `datos`.

### b) `bind_cols()`

Otra cosa que podemos hacer es, simplemente, pegar una columna de un dataframe a otro. Para ello recurrimos a la función `bind_cols()` de `dplyr`:

```{r bind_cols, echo = T}
a <- select(datos, 1:5) # Seleccionamos las primeras cinco columnas de datos
b <- select(datos, 3:7) # Seleccionamos las últimas cinco columnas de datos
col_un <- bind_cols(a, b) #Unimos ambos dataframes a partir de sus columnas
head(col_un)
```

Vemos que simplemente pegó  `a` y `b`. Eso implica que tenemos columnas repetidas. Cuando estemos seguras/os de que hay columnas repetidas entre dos dataframes que queramos unir, emplearemos `merge()` mientras que, si estos no comparten ninguna columna, recurrimos a `bing_cols()`

### c) `bind_rows()`

También podemos unir dos dataframes a partir de sus filas, con la función `bind_rows()` de `dplyr`

```{r bind_rows, echo = T}
a <- a[1:10000,] # Seleccionamos las primeras 10.000 filas de a
b <- b[10001:18985,] # Seleccionamos las últimas 8.985 filas de b
row_un <- bind_rows(a, b)
head(row_un)
```

`bind_rows()` nos permite pegar filas, independientemente si ambos dataframes comparten las mismas columnas. En caso de que ambos dataframes no compartan alguna columna, esta función rellenará con valores nulos (`NA`)

# Resumen

En este práctico aprendimos a

1. Agrupar datos por filas y columnas.
2. Manipular datos (tidydata), transformando la estructura de estos a una ancha o larga. 
3. Separar y unir caracteres de una columna.
4. Unir datos, a partir de filas y columnas. 

# Reporte de progreso

¡No olviden llenar el [reporte de progreso](https://learn-r.formr.org)! En tu correo electrónico está disponible el código mediante al cuál debes acceder para actualizar tu estado de avance del curso.


